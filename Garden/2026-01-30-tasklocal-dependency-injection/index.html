<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="의존성 주입이라고 하면 보통 생성자나 함수 인자로 넘기는 방식을 먼저 떠올린다. 그런데 Date, UUID, Locale 같은 값은 “현재 시각”, “새 ID”, “현재 로케일”처럼 전역·환경에 가깝기 때문에 매 레이어마다 인자로 넘기기 애매하다." />
    <meta name="author" content="Hogumachu" />
    <meta name="generator" content="Ignite v0.6.0" />
    <title>TaskLocal로 스레드 안전한 의존성 주입하기 – The Steady Company</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/css/prism-xcode-dark.css" rel="stylesheet" data-highlight-theme="xcode-dark" />
    <link href="/css/prism-xcode-light.css" rel="stylesheet" data-highlight-theme="xcode-light" />
    <link href="/css/prism-plugins.css" rel="stylesheet" />
    <link href="/css/bootstrap-icons.min.css" rel="stylesheet" />
    <link href="/css/ignite-core.min.css" rel="stylesheet" />
    <link href="https://thesteadycompany.github.io/Garden/2026-01-30-tasklocal-dependency-injection" rel="canonical" />
    <script>(function() {
    function getThemePreference() {
        return localStorage.getItem('custom-theme') || 'auto';
    }

    function applyTheme(themeID) {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const lightThemeID = document.documentElement.getAttribute('data-light-theme') || 'light';
        const darkThemeID = document.documentElement.getAttribute('data-dark-theme') || 'dark';
        const actualThemeID = themeID === 'auto' ? (prefersDark ? darkThemeID : lightThemeID) : themeID;

        document.documentElement.setAttribute('data-bs-theme', actualThemeID);
        document.documentElement.setAttribute('data-theme-state', themeID);
    }

    function applySyntaxTheme() {
        const syntaxTheme = getComputedStyle(document.documentElement)
            .getPropertyValue('--syntax-highlight-theme').trim().replace(/"/g, '');

        if (!syntaxTheme) return;

        document.querySelectorAll('link[data-highlight-theme]').forEach(link => {
            link.setAttribute('disabled', 'disabled');
        });

        const themeLink = document.querySelector(`link[data-highlight-theme="${syntaxTheme}"]`);
        if (themeLink) {
            themeLink.removeAttribute('disabled');
        }
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const currentTheme = getThemePreference();
        if (currentTheme === 'auto') {
            applyTheme('auto');
            applySyntaxTheme();
        }
    });

    const savedTheme = getThemePreference();
    applyTheme(savedTheme);
    applySyntaxTheme();
})();
</script>
    <meta property="og:site_name" content="Docs" />
    <meta property="og:title" content="TaskLocal로 스레드 안전한 의존성 주입하기" />
    <meta name="twitter:title" content="TaskLocal로 스레드 안전한 의존성 주입하기" />
    <meta property="og:description" content="의존성 주입이라고 하면 보통 생성자나 함수 인자로 넘기는 방식을 먼저 떠올린다. 그런데 Date, UUID, Locale 같은 값은 “현재 시각”, “새 ID”, “현재 로케일”처럼 전역·환경에 가깝기 때문에 매 레이어마다 인자로 넘기기 애매하다." />
    <meta name="twitter:description" content="의존성 주입이라고 하면 보통 생성자나 함수 인자로 넘기는 방식을 먼저 떠올린다. 그런데 Date, UUID, Locale 같은 값은 “현재 시각”, “새 ID”, “현재 로케일”처럼 전역·환경에 가깝기 때문에 매 레이어마다 인자로 넘기기 애매하다." />
    <meta property="og:url" content="https://thesteadycompany.github.io/Garden/2026-01-30-tasklocal-dependency-injection" />
    <meta name="twitter:domain" content="thesteadycompany.github.io" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:dnt" content="on" />
  </head>
  <body class="container">
    <div class="pb-5">
      <header>
        <nav class="fixed-top material-ultra-thin navbar navbar-expand-md">
          <div class="container flex-wrap flex-lg-nowrap">
            <div class="me-2 me-md-auto">
              <a href="/" class="d-inline-flex align-items-center navbar-brand"><span style="font-weight: 700; font-family: 'Space Grotesk'; font-size: 1.0em">THE STEADY COMPANY</span></a>
            </div>
            <button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div id="navbarCollapse" class="collapse navbar-collapse">
              <ul class="navbar-nav mb-2 mb-md-0 col justify-content-end">
                <li class="nav-item"><a href="/garden-page" class="nav-link text-nowrap">Garden</a></li>
                <li class="nav-item"><a href="https://hogumachu.github.io" class="nav-link text-nowrap"><span>Personal Blog</span></a></li>
              </ul>
            </div>
          </div>
        </nav>
      </header>
    </div>
    <div class="ig-main-content">
      <h1 class="text-center text-primary pt-5">TaskLocal로 스레드 안전한 의존성 주입하기</h1>
      <p class="text-center text-body-secondary pb-5">주입하기 애매한 Date, UUID, Locale을 컨텍스트로 다루는 법</p>
      <p class="m-3 p-3"></p>
      <p>의존성 주입이라고 하면 보통 생성자나 함수 인자로 넘기는 방식을 먼저 떠올린다.<br /> 그런데 Date, UUID, Locale 같은 값은 “현재 시각”, “새 ID”, “현재 로케일”처럼<br /> 전역·환경에 가깝기 때문에 매 레이어마다 인자로 넘기기 애매하다.</p>
      <p>swift-dependencies처럼 “컨텍스트 기반 DI”를 쓰면<br /> 이런 의존성도 테스트 가능하고 스레드 안전하게 다룰 수 있다는 걸<br /> <strong>TaskLocal</strong>로 직접 구현해보면서 정리해봤다.</p>
      <hr />
      <h2>왜 “주입하기 애매한” 의존성이 있는가</h2>
      <p><strong>Date, UUID, Locale</strong>은 앱 전역에서 쓰이지만,<br /> 매번 <code>init(date: Date, uuid: UUID, locale: Locale)</code>처럼 넘기자니 시그니처가 부풀어 오르고,<br /> 실제로는 대부분 “지금 시각”, “새 UUID”, “현재 로케일” 한 가지 구현만 쓴다.</p>
      <p><strong>이미지 디스크 캐시</strong>처럼 앱 전역에서 하나만 쓰는 객체도 비슷하다.<br /> 프로덕션에서는 한 인스턴스를 쓰고, 테스트에서만 mock/stub으로 바꾸고 싶은데<br /> 생성자로만 주입하려면 그 객체를 쓰는 모든 경로에 인자가 붙어야 한다.</p>
      <p>정리하면, “싱글톤처럼 한 번 정해진 값을 어디서든 쓰고 싶지만,<br /> 테스트·스레드 안전하게 바꿀 수 있는” 수단이 필요하다.</p>
      <hr />
      <h2>TaskLocal이 주는 것: 스레드 안전 + 태스크 스코프</h2>
      <p><strong>TaskLocal</strong>은 Swift가 제공하는 메커니즘으로,<br /> 스레드 로컬처럼 “현재 실행 컨텍스트(태스크)“에 값을 묶어 둔다.</p>
      <p>싱글톤처럼 “한 번 정해진 값을 어디서든 쓰는” 느낌을 주면서,<br /> <strong>태스크 단위로</strong> 다른 값으로 덮어쓸 수 있다.<br /> 그래서 테스트에서만 <code>withValue</code>로 고정된 Date, UUID, Locale을 넣어 주면 되고,<br /> 프로덕션 코드는 생성자 인자를 늘리지 않아도 된다.</p>
      <hr />
      <h2>1. 가장 단순한 형태: SimpleDependency</h2>
      <p>구현 난이도가 가장 낮다.<br /> 타입당 <strong>TaskLocal 하나</strong>만 두는 방식이다.<br /> <code>@TaskLocal public static var current</code>에 클로저를 넣어 두고, 호출부에서는 <code>current()</code>처럼 쓴다.</p>
      <pre><code class="language-swift">public enum SimpleDateGenerator {
  @TaskLocal public static var current: @Sendable () -&gt; Date = { Date() }
}

public enum SimpleUUIDGenerator {
  @TaskLocal public static var current: @Sendable () -&gt; UUID = { UUID() }
}

public enum SimpleLocaleGenerator {
  @TaskLocal public static var current: @Sendable () -&gt; Locale = { .current }
}
</code></pre>
      <p>View에서는 생성자로 Date/UUID/Locale을 받지 않고,<br /> <code>SimpleDateGenerator.current()</code>, <code>SimpleUUIDGenerator.current()</code>처럼 현재 컨텍스트에서 꺼내 쓴다.</p>
      <p>테스트에서는 <code>$current.withValue</code>로 해당 태스크 안에서만 값을 덮어쓴다.</p>
      <pre><code class="language-swift">@Test @MainActor func testDate() async throws {
  let now = Date(timeIntervalSince1970: 0)
  SimpleDateGenerator.$current.withValue({ now }) {
    let view = SimpleDependencyView()
    #expect(view.date == now)
  }
}
</code></pre>
      <p>“타입당 TaskLocal 하나”만 있어도,<br /> 생성자 인자 없이 View/비즈니스 로직에서 값을 쓰고, 테스트에서만 덮어쓸 수 있다.</p>
      <hr />
      <h2>2. 컨테이너 하나로 모으기: ContainerDependency</h2>
      <p>난이도는 Simple보다 한 단계 올라간다.<br /> TaskLocal에는 “값 하나”만 둘 수 있으므로,<br /> date, uuid, locale을 담은 <strong>구조체 하나</strong>를 통째로 넣는 방식이다.</p>
      <pre><code class="language-swift">public enum ContainerDependencyValues {
  @TaskLocal public static var current = ContainerDependencyContainer()
}

public struct ContainerDependencyContainer: Sendable {
  public var date: @Sendable () -&gt; Date
  public var uuid: @Sendable () -&gt; UUID
  public var locale: @Sendable () -&gt; Locale

  public init(
    date: @Sendable @escaping () -&gt; Date = { Date() },
    uuid: @Sendable @escaping () -&gt; UUID = { UUID() },
    locale: @Sendable @escaping () -&gt; Locale = { Locale.current }
  ) {
    self.date = date
    self.uuid = uuid
    self.locale = locale
  }
}

@propertyWrapper
public struct ContainerDependency&lt;Value&gt; {
  private let keyPath: KeyPath&lt;ContainerDependencyContainer, Value&gt;

  public var wrappedValue: Value {
    ContainerDependencyValues.current[keyPath: keyPath]
  }
  public init(_ keyPath: KeyPath&lt;ContainerDependencyContainer, Value&gt;) {
    self.keyPath = keyPath
  }
}
</code></pre>
      <p><code>withDependencies</code>는 컨테이너를 하나 만들고, 필요한 필드만 바꾼 뒤 TaskLocal에 넣어 operation을 실행한다.</p>
      <pre><code class="language-swift">public func withDependencies&lt;T&gt;(
  _ configure: (inout ContainerDependencyContainer) -&gt; Void,
  operation: () async throws -&gt; T
) async rethrows -&gt; T {
  var deps = ContainerDependencyContainer()
  configure(&amp;deps)
  return try await ContainerDependencyValues.$current.withValue(deps, operation: operation)
}
</code></pre>
      <p>View 사용법은 Simple보다 나아진다. <code>@ContainerDependency(\.date)</code> 등으로 접근한다.</p>
      <p>다만 단점이 있다.<br /> <strong>연관 없는 의존성</strong>을 하나의 구조체에 몰아넣다 보니 응집도가 떨어진다.<br /> Date/UUID/Locale은 서로 역할이 다른데, 같은 컨테이너에 묶여 있다.<br /> 그리고 <strong>확장성</strong>이 없다. 새 의존성(예: 이미지 캐시)을 넣으려면 <code>ContainerDependencyContainer</code> 정의를 매번 수정해야 한다.</p>
      <hr />
      <h2>3. swift-dependencies 스타일: ProtocolDependency</h2>
      <p>구현 난이도는 세 가지 중 가장 높지만, <strong>사용성은 가장 좋다.</strong><br /> Container의 단점(응집도·확장성)을 Key 기반 설계로 해결한 형태다.</p>
      <p>의존성을 <strong>한 컨테이너에 모으되, Key로 접근</strong>한다.<br /> 각 Key가 자기 타입만 책임지므로 연관 없는 것끼리 한 덩어리로 묶이지 않고,<br /> 새 의존성은 Key + defaultValue만 추가하면 되므로 확장이 자유롭다.</p>
      <p><strong>DependencyKey</strong>와 <strong>DependencyValues</strong>(TaskLocal)로 “현재 컨텍스트의 의존성 모음”을 표현한다.</p>
      <pre><code class="language-swift">public protocol DependencyKey {
  associatedtype Value: Sendable
  static var defaultValue: Value { get }
}

public struct DependencyValues: Sendable {
  @TaskLocal public static var current = DependencyValues()

  private var storage: [ObjectIdentifier: any Sendable] = [:]

  public subscript&lt;Key: DependencyKey&gt;(key: Key.Type) -&gt; Key.Value {
    get {
      guard let value = storage[ObjectIdentifier(key)] as? Key.Value else {
        return Key.defaultValue
      }
      return value
    }
    set {
      storage[ObjectIdentifier(key)] = newValue
    }
  }
}

@propertyWrapper
public struct Dependency&lt;Value&gt; {
  private let keyPath: KeyPath&lt;DependencyValues, Value&gt;

  public init(_ keyPath: KeyPath&lt;DependencyValues, Value&gt;) {
    self.keyPath = keyPath
  }

  public var wrappedValue: Value {
    DependencyValues.current[keyPath: keyPath]
  }
}
</code></pre>
      <p>Date, UUID, Locale은 Key + DependencyValues 확장으로 등록한다.</p>
      <pre><code class="language-swift">public struct DateGeneratorKey: DependencyKey {
  public static let defaultValue: @Sendable () -&gt; Date = { Date() }
}

extension DependencyValues {
  public var date: @Sendable () -&gt; Date {
    get { self[DateGeneratorKey.self] }
    set { self[DateGeneratorKey.self] = newValue }
  }
}
</code></pre>
      <p><strong>withDependencies</strong>로 “이 operation 안에서만” 의존성을 바꿔서 실행한다.</p>
      <pre><code class="language-swift">public func withDependencies&lt;T&gt;(
  _ configure: (inout DependencyValues) -&gt; Void,
  operation: () async throws -&gt; T
) async rethrows -&gt; T {
  var deps = DependencyValues.current
  configure(&amp;deps)
  return try await DependencyValues.$current
    .withValue(deps, operation: operation)
}
</code></pre>
      <p>View에서는 생성자 주입 없이 <code>@Dependency(\.date)</code> 등으로 접근한다.</p>
      <pre><code class="language-swift">struct ProtocolDependencyView: View {
  @Dependency(\.date) var date
  @Dependency(\.uuid) var uuid
  @Dependency(\.locale) var locale

  var body: some View {
    // ...
    DateView(date: date())
    UUIDView(uuid: uuid())
    LocaleView(locale: locale)
  }
}
</code></pre>
      <p>테스트에서는 <code>withDependencies</code> 안에서만 mock으로 교체한다.</p>
      <pre><code class="language-swift">await withDependencies {
  $0.date = { now }
} operation: {
  let view = ProtocolDependencyView()
  #expect(view.date() == now)
}
</code></pre>
      <p>새 의존성(예: 이미지 캐시)은 <strong>Key + defaultValue</strong>만 추가하고,<br /> <code>DependencyValues</code>에 프로퍼티만 붙이면 호출부는 그대로 <code>@Dependency(\.imageCache)</code>로 사용할 수 있다.</p>
      <p>세 가지를 한 줄로 정리하면:</p>
      <ul>
        <li><strong>SimpleDependency</strong>: 구현이 가장 쉽고 단순. 타입별 TaskLocal 하나씩.</li>
        <li><strong>ContainerDependency</strong>: 한 단계 복잡. 단일 구조체 컨테이너. 다만 응집도·확장성은 아쉽다.</li>
        <li><strong>ProtocolDependency</strong>: 구현은 가장 어렵지만 사용성은 가장 좋다. Key 기반으로 응집도와 확장성을 모두 잡는다.</li>
      </ul>
      <hr />
      <h2>정리 및 활용 포인트</h2>
      <p>Date, UUID, Locale, 이미지 디스크 캐시처럼 “주입받기 애매한” 의존성은<br /> TaskLocal + (필요하면) Key/Container 패턴으로 깔끔하게 다룰 수 있다.</p>
      <ul>
        <li><strong>테스트</strong>: 생성자/함수 시그니처를 바꾸지 않고,<br /> <code>withValue</code> / <code>withDependencies</code> scope 안에서만 mock으로 교체하면 된다.</li>
        <li><strong>스레드 안전</strong>: TaskLocal은 태스크 단위로 격리되므로, 동시에 여러 태스크가 있어도 서로 덮어쓰지 않는다.</li>
        <li>swift-dependencies 라이브러리를 쓰지 않아도,<br /> 같은 아이디어를 프로젝트 규모에 맞게 Simple → Container → Protocol 중에서 선택해서 구현할 수 있다.<br /> 난이도와 사용성을 고려하면 1→2→3 순서로 갈수록 구현은 복잡해지고, 대신 사용성과 확장성이 좋아진다.</li>
      </ul>
      <hr />
      <h2>마치며</h2>
      <p>매번 인자로 넘기지 않아도, TaskLocal로 스레드 안전하고 테스트 가능한 의존성 주입을 할 수 있다는 걸<br /> Simple → Container → Protocol 순으로, 난이도가 올라가면서 사용성도 함께 올라가는 세 가지 형태로 구현해 보면서 정리했다.</p>
      <p>주입하기 애매한 의존성이 생길 때마다 “생성자에 또 넣을까” 말고,<br /> “TaskLocal로 컨텍스트에 묶어 두고 테스트에서만 바꿀까”를 한 번 떠올려 보면 좋겠다.</p>
      <p>참고:</p>
      <ul>
        <li><a href="https://github.com/pointfreeco/swift-dependencies">pointfreeco/swift-dependencies</a></li>
        <li><a href="https://github.com/thesteadycompany/Samples/tree/main/Dependency">샘플 코드</a></li>
      </ul>
      <p></p>
    </div>
    <div class="mt-5 fs-3 vstack gap-3">
      <div class="mb-0 align-self-center hstack gap-3">
        <a target="_blank" rel="noreferrer" href="https://github.com/thesteadycompany" class="mb-0 align-self-center link-secondary"><i class="bi-github"></i></a>
        <a target="_blank" rel="noreferrer" href="https://www.linkedin.com/in/hogumachu/" class="mb-0 align-self-center link-secondary"><i class="bi-linkedin"></i></a>
      </div>
      <div class="mb-0 align-self-center">
        <div class="animation-sWfAv-hover" style="transform-style: preserve-3d">
          <div class="hstack gap-1">
            <div role="group" class="btn-group" aria-label="Theme Switch Buttons">
              <button type="button" class="btn" onclick="igniteSwitchTheme('light');"><i class="bi-sun-fill" style="color: rgb(255 255 255 / 70%)"></i></button>
              <button type="button" class="btn" onclick="igniteSwitchTheme('dark');"><i class="bi-moon-fill" style="color: rgb(0 0 0 / 70%)"></i></button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/syntax-highlighting.js"></script>
    <script src="/js/ignite-core.js"></script>
  </body>
</html>