<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="앱의 외부 모듈 의존성을 추상화하는 작업이 거의 끝났다.생각보다 꽤 오랜 시간이 걸린 작업이었지만, 결과를 놓고 보면 충분히 의미 있는 선택이었다고 느낀다." />
    <meta name="author" content="Hogumachu" />
    <meta name="generator" content="Ignite v0.6.0" />
    <title>외부 모듈 의존성 추상화 이후의 성과와 다음 고민 – The Steady Company</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/css/prism-xcode-dark.css" rel="stylesheet" data-highlight-theme="xcode-dark" />
    <link href="/css/prism-xcode-light.css" rel="stylesheet" data-highlight-theme="xcode-light" />
    <link href="/css/prism-plugins.css" rel="stylesheet" />
    <link href="/css/bootstrap-icons.min.css" rel="stylesheet" />
    <link href="/css/ignite-core.min.css" rel="stylesheet" />
    <link href="https://thesteadycompany.github.io/Garden/2025-01-15-external-dependency-abstraction" rel="canonical" />
    <script>(function() {
    function getThemePreference() {
        return localStorage.getItem('custom-theme') || 'auto';
    }

    function applyTheme(themeID) {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const lightThemeID = document.documentElement.getAttribute('data-light-theme') || 'light';
        const darkThemeID = document.documentElement.getAttribute('data-dark-theme') || 'dark';
        const actualThemeID = themeID === 'auto' ? (prefersDark ? darkThemeID : lightThemeID) : themeID;

        document.documentElement.setAttribute('data-bs-theme', actualThemeID);
        document.documentElement.setAttribute('data-theme-state', themeID);
    }

    function applySyntaxTheme() {
        const syntaxTheme = getComputedStyle(document.documentElement)
            .getPropertyValue('--syntax-highlight-theme').trim().replace(/"/g, '');

        if (!syntaxTheme) return;

        document.querySelectorAll('link[data-highlight-theme]').forEach(link => {
            link.setAttribute('disabled', 'disabled');
        });

        const themeLink = document.querySelector(`link[data-highlight-theme="${syntaxTheme}"]`);
        if (themeLink) {
            themeLink.removeAttribute('disabled');
        }
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const currentTheme = getThemePreference();
        if (currentTheme === 'auto') {
            applyTheme('auto');
            applySyntaxTheme();
        }
    });

    const savedTheme = getThemePreference();
    applyTheme(savedTheme);
    applySyntaxTheme();
})();
</script>
    <meta property="og:site_name" content="Docs" />
    <meta property="og:title" content="외부 모듈 의존성 추상화 이후의 성과와 다음 고민" />
    <meta name="twitter:title" content="외부 모듈 의존성 추상화 이후의 성과와 다음 고민" />
    <meta property="og:description" content="앱의 외부 모듈 의존성을 추상화하는 작업이 거의 끝났다.생각보다 꽤 오랜 시간이 걸린 작업이었지만, 결과를 놓고 보면 충분히 의미 있는 선택이었다고 느낀다." />
    <meta name="twitter:description" content="앱의 외부 모듈 의존성을 추상화하는 작업이 거의 끝났다.생각보다 꽤 오랜 시간이 걸린 작업이었지만, 결과를 놓고 보면 충분히 의미 있는 선택이었다고 느낀다." />
    <meta property="og:url" content="https://thesteadycompany.github.io/Garden/2025-01-15-external-dependency-abstraction" />
    <meta name="twitter:domain" content="thesteadycompany.github.io" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:dnt" content="on" />
  </head>
  <body class="container">
    <div class="pb-5">
      <header>
        <nav class="fixed-top material-ultra-thin navbar navbar-expand-md">
          <div class="container flex-wrap flex-lg-nowrap">
            <div class="me-2 me-md-auto">
              <a href="/" class="d-inline-flex align-items-center navbar-brand"><span style="font-weight: 700; font-family: 'Space Grotesk'; font-size: 1.0em">THE STEADY COMPANY</span></a>
            </div>
            <button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div id="navbarCollapse" class="collapse navbar-collapse">
              <ul class="navbar-nav mb-2 mb-md-0 col justify-content-end">
                <li class="nav-item"><a href="/garden-page" class="nav-link text-nowrap">Garden</a></li>
                <li class="nav-item"><a href="https://hogumachu.github.io" class="nav-link text-nowrap"><span>Personal Blog</span></a></li>
              </ul>
            </div>
          </div>
        </nav>
      </header>
    </div>
    <div class="ig-main-content">
      <h1 class="text-center text-primary pt-5">외부 모듈 의존성 추상화 이후의 성과와 다음 고민</h1>
      <p class="text-center text-body-secondary pb-5">빌드 속도 개선과 Mock 전략의 한계</p>
      <p class="m-3 p-3"></p>
      <p>앱의 <strong>외부 모듈 의존성을 추상화하는 작업</strong>이 거의 끝났다.<br />생각보다 꽤 오랜 시간이 걸린 작업이었지만, 결과를 놓고 보면 충분히 의미 있는 선택이었다고 느낀다.</p>
      <p>특히 이번 작업은 “구조가 좋아졌다”라는 추상적인 만족이 아니라,<br /><strong>수치로 성과가 드러난 작업</strong>이라는 점에서 더 인상 깊었다.</p>
      <hr />
      <h2>🚀 빌드 속도로 확인한 성과</h2>
      <p>클린 빌드를 기준으로 개발 환경과 프로덕션 환경의 빌드 속도를 비교해 보았다.</p>
      <ul>
        <li><strong>클린 빌드</strong>
          <ul>
            <li>Production: 약 <strong>300초</strong></li>
            <li>Development: 약 <strong>150초</strong></li>
          </ul></li>
      </ul>
      <p>개발 환경 기준으로는 절반 수준까지 줄어든 셈이다.</p>
      <p>증분 빌드에서는 차이가 더 명확했다.</p>
      <ul>
        <li><strong>증분 빌드</strong>
          <ul>
            <li>Production: 약 <strong>20초</strong></li>
            <li>Development: 약 <strong>8초</strong></li>
          </ul></li>
      </ul>
      <p>개발 사이클에서 가장 자주 겪는 증분 빌드 시간이 줄어드니<br />작업 흐름 자체가 훨씬 쾌적해졌다.</p>
      <p>수치로 확인하니<br />“열심히 한 보람이 있다”라는 생각이 자연스럽게 들었다.</p>
      <hr />
      <h2>🧩 추상화 이후, Mock이 남겼던 고민</h2>
      <p>의존성 추상화를 진행하면서 자연스럽게 따라온 과제는<br /><strong>API Mock 전략</strong>이었다.</p>
      <p>Mock 객체 자체를 만드는 일은 생각보다 어렵지 않았다.</p>
      <ul>
        <li>AI를 활용해 Mock 구현을 빠르게 만들 수 있고</li>
        <li>주석이나 기본 시나리오 정리도 깔끔하게 된다</li>
      </ul>
      <p>그럼에도 불구하고,<br />실제 개발 과정에서는 <strong>미묘한 병목</strong>이 계속 발생했다.</p>
      <hr />
      <h2>🔁 현재의 Mock 개발 프로세스</h2>
      <p>지금의 흐름은 대략 이렇다.</p>
      <ol>
        <li>API에서 다른 응답이 필요해짐</li>
        <li>AI에게 Mock 객체를 다른 응답으로 수정해달라고 요청</li>
        <li>Mock 반영</li>
        <li><strong>다시 빌드</strong></li>
        <li>결과 확인</li>
      </ol>
      <p>UI 코드 변경처럼 핫리로드가 잘 동작하는 경우에는 문제가 크지 않다.<br />하지만,</p>
      <ul>
        <li>비즈니스 로직이 변경되거나</li>
        <li>API 응답 구조가 달라지는 경우</li>
      </ul>
      <p>결국 <strong>다시 빌드해야 하는 상황</strong>이 된다.</p>
      <p>Mock 객체를 여러 개 만들어 핫리로드로 전환하는 방식도 고민해봤지만,</p>
      <ul>
        <li>구조가 복잡해지고</li>
        <li>관리 비용이 늘어나며</li>
        <li>빌드 의존성 문제를 근본적으로 해결하지는 못한다</li>
      </ul>
      <p>는 한계가 있었다.</p>
      <hr />
      <h2>💡 Vapor 기반 로컬 서버라는 대안</h2>
      <p>이런 고민 끝에 떠오른 선택지가 하나 있었다.</p>
      <blockquote>
        <p><strong>Vapor를 이용해 로컬 서버를 두는 방식</strong></p>
      </blockquote>
      <p>이미 Swift 언어로 정의된 Response Model이 존재하니,<br />그 모델을 그대로 서버 쪽에서 사용하면<br />굳이 앱 내부에 Mock 객체를 둘 필요가 없지 않을까 하는 생각이었다.</p>
      <hr />
      <h2>🔄 로컬 서버를 사용했을 때의 흐름</h2>
      <p>로컬 서버를 사용한다면, 개발 흐름은 이렇게 바뀐다.</p>
      <ol>
        <li>API에서 다른 응답이 필요해짐</li>
        <li>AI에게 서버 응답을 다른 형태로 수정 요청</li>
        <li>반영</li>
        <li><strong>바로 확인</strong></li>
      </ol>
      <p>앱을 다시 빌드할 필요는 없어진다.<br />물론 서버 역시 다시 빌드되어야 하지만,</p>
      <ul>
        <li>앱 전체 빌드에 비하면 훨씬 가볍고</li>
        <li>로컬 서버를 정말 라이트하게 구성한다면</li>
        <li>반복 피드백 속도는 체감될 정도로 빨라질 가능성이 있다</li>
      </ul>
      <hr />
      <h2>🤔 Mock과 로컬 서버 사이에서</h2>
      <p>정리해보면 두 방식은 명확한 성격 차이가 있다.</p>
      <ul>
        <li><strong>Mock 객체</strong>
          <ul>
            <li>구조가 단순하다</li>
            <li>테스트 코드와 궁합이 좋다</li>
            <li>하지만 빌드 사이클에서 자유롭지 않다</li>
          </ul></li>
        <li><strong>로컬 서버</strong>
          <ul>
            <li>실제 API 흐름과 유사하다</li>
            <li>개발 중 피드백 루프가 빠르다</li>
            <li>초기 세팅 비용이 있다</li>
          </ul></li>
      </ul>
      <p>아직 어느 쪽이 정답이라고 단정하기는 어렵다.<br />다만 지금 시점에서는,</p>
      <blockquote>
        <p>Mock을 더 정교하게 만드는 것보다<br /><strong>개발 흐름 전체를 빠르게 만드는 선택</strong>이 더 중요해 보인다.</p>
      </blockquote>
      <hr />
      <h2>🧠 정리하며</h2>
      <p>외부 모듈 의존성 추상화는<br />구조 안정성과 빌드 성능 모두에서 분명한 성과를 가져왔다.</p>
      <p>이제 관심사는 기술적인 완성도보다는<br /><strong>개발 경험과 피드백 속도</strong>에 더 가까워지고 있다.</p>
      <p>다음 단계에서는<br />Mock과 로컬 서버를 어떻게 조합할지,<br />혹은 전혀 다른 방식이 나올지<br />조금 더 실험해볼 생각이다.</p>
      <p></p>
    </div>
    <div class="mt-5 fs-3 vstack gap-3">
      <div class="mb-0 align-self-center hstack gap-3">
        <a target="_blank" rel="noreferrer" href="https://github.com/thesteadycompany" class="mb-0 align-self-center link-secondary"><i class="bi-github"></i></a>
        <a target="_blank" rel="noreferrer" href="https://www.linkedin.com/in/hogumachu/" class="mb-0 align-self-center link-secondary"><i class="bi-linkedin"></i></a>
      </div>
      <div class="mb-0 align-self-center">
        <div class="animation-sWfAv-hover" style="transform-style: preserve-3d">
          <div class="hstack gap-1">
            <div role="group" class="btn-group" aria-label="Theme Switch Buttons">
              <button type="button" class="btn" onclick="igniteSwitchTheme('light');"><i class="bi-sun-fill" style="color: rgb(255 255 255 / 70%)"></i></button>
              <button type="button" class="btn" onclick="igniteSwitchTheme('dark');"><i class="bi-moon-fill" style="color: rgb(0 0 0 / 70%)"></i></button>
            </div>
          </div>
        </div>
      </div>
    </div>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/syntax-highlighting.js"></script>
    <script src="/js/ignite-core.js"></script>
  </body>
</html>